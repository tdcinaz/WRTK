import sys
import numpy as np
import nibabel as nib
import vtk
from vtkmodules.util import numpy_support
import pyvista as pv
import pyacvd
import logging
from collections import defaultdict, deque
from scipy.spatial import cKDTree
import os
import re

def nifti_to_pv_image_data(nifti_img):
    """
    Convert a 3D NIfTI image to vtkImageData.

    Args:
        nifti_img (nibabel.Nifti1Image): The input NIfTI image.

    Returns:
        pv.ImageData: The image data in pyvista format.
    """
    # 1) Get the NumPy array from the NIfTI
    data_array = nifti_img.get_fdata(dtype=np.float32)

    # Ensure it's contiguous in memory
    data_array = np.ascontiguousarray(data_array)

    # 2) Retrieve voxel spacing from the header
    #    If it's a 4D image, nibabel header might return 4 zooms, so we take only the first three.
    pixdim = nifti_img.header.get_zooms()[:3]

    # 3) Extract the translation (origin) from the affine
    origin = nifti_img.affine[:3, 3]

    # 4) Create pyvista ImageData

    pv_image = pv.ImageData(
        dimensions=data_array.shape, 
        spacing=(pixdim[2], pixdim[1], pixdim[0]), 
        origin=(origin[2], origin[1], origin[0]),
        deep=True)
    
    pv_image.point_data["Scalars"] = data_array.flatten()

    return pv_image

def compute_label_volumes(img, label_range=range(1, 14)):
    # Load the image
    data = img.get_fdata()
    
    # Get the voxel size from the header (voxel volume in mm³)
    voxel_volume = np.prod(img.header.get_zooms())
    print(f"Voxel volume: {voxel_volume:.2f} mm³")

    # Compute volumes for each label
    volumes = {}
    for label in label_range:
        voxel_count = np.sum(data == label)
        volumes[label] = voxel_count * voxel_volume

    return volumes

def extract_labeled_surface_from_volume(
    input_vtk_image: pv.ImageData,
) -> pv.PolyData:
    """
    Extract a multi-labeled surface using vtkSurfaceNets3D.
    The output polydata has a cell-data array 'BoundaryLabels'
    indicating which label is adjacent to either side of the cell.

    Args:
        nifti_file (str): Path to a labeled NIfTI image with integer labels.

    Returns:
        vtk.vtkPolyData: A polydata containing the labeled surface
    """


    surface_net = vtk.vtkSurfaceNets3D()
    surface_net.SetInputData(input_vtk_image)
    surface_net.SetBackgroundLabel(0)
    surface_net.SetOutputStyleToDefault()
    surface_net.GenerateLabels(14, 1, 14)
    #surface_net.SmoothingOff()
    #surface_net.SetOutputMeshTypeToQuads()

    surface_net.Update()
    pv_surface_net: pv.PolyData = pv.wrap(surface_net.GetOutput())

    logging.info(f"    ++++ : Cells before cleaning: {pv_surface_net.GetNumberOfCells()}")

    pv_surface_net.clean()

    logging.info(f"    ++++ : Cells after cleaning: {pv_surface_net.GetNumberOfCells()}")

    return pv_surface_net



def extract_individual_surfaces(
    labeledSurface,
    labelArrayName="BoundaryLabels",
    possibleLabels=range(1, 14),
) -> pv.PolyData:

    def attachOriginalCellIds(polyData, arrayName="vtkOriginalCellIds"):
        """
        Attach a cell-data array of unique IDs (0,1,2,...,N-1) 
        to the input vtkPolyData, so that after thresholding 
        you can identify the original cell IDs.
        """
        numCells = polyData.GetNumberOfCells()
        
        # Create a new ID array
        cellIds = vtk.vtkIdTypeArray()
        cellIds.SetName(arrayName)
        cellIds.SetNumberOfComponents(1)
        cellIds.SetNumberOfTuples(numCells)
        
        for i in range(numCells):
            cellIds.SetValue(i, i)
        
        # Attach this array to the cell data
        polyData.GetCellData().AddArray(cellIds)

    def extractNonStandardAdjSurfaces(
        inputPolyData: vtk.vtkPolyData,
        labelID: float,
        standardAdj: dict,
        boundaryArrayName: str = "BoundaryLabels"
    ) -> vtk.vtkPolyData:
        """
        Extract surfaces from a vtkPolyData (generated by vtkSurfaceNets3D)
        whose CellData contains an array 'BoundaryLabels' with 2 components
        (component 0, component 1). The extraction logic is:
        
        1) Keep cells that have labelID in component 0 or 1
        2) Exclude cells if the *other* component is in standardAdj[labelID].
        
        :param inputPolyData: The input surface from which to extract
        :param labelID: The label of interest (e.g. 11.0)
        :param standardAdj: A dict that maps label -> tuple/list of standard-adjacent labels
                        e.g. standardAdj[11.0] = (6.0, 8.0)
        :param boundaryArrayName: The name of the array with boundary labels
        :return: A vtkPolyData containing the extracted surfaces
        """

        # ---------------------------
        # 1. Threshold: component 0 == labelID
        # ---------------------------
        threshComp0 = vtk.vtkThreshold()
        threshComp0.SetInputData(inputPolyData)
        # We tell vtkThreshold that we are working with CellData,
        # array 'BoundaryLabels', and we want to use component 0.
        threshComp0.SetInputArrayToProcess(
            0, 0, 0, vtk.vtkDataObject.FIELD_ASSOCIATION_CELLS, boundaryArrayName
        )
        threshComp0.SetUpperThreshold(labelID)
        threshComp0.SetLowerThreshold(labelID)
        threshComp0.Between(labelID)
        threshComp0.Update()
        
        # We now have an unstructured grid. Next, we need to exclude
        # any cells where component 1 is in standardAdj[labelID].
        # We'll do this by thresholding for component 1 being in that set
        # and then "inverting" that selection.
        
        # For the adjacency we want to exclude:
        adjLabels = standardAdj.get(labelID, ())

        # Convert the above threshold to PolyData so we can re-threshold
        geometryComp0 = vtk.vtkGeometryFilter()
        geometryComp0.SetInputConnection(threshComp0.GetOutputPort())
        geometryComp0.Update()

        usgComp0 = polyDataToUnstructuredGrid(geometryComp0.GetOutput())

        # If we have adjacency labels, filter them out:
        if len(adjLabels) > 0:
            # We'll keep track of anything that matches adjacency in comp1
            # so we can remove it from the "good" set.
            appendedAdjsComp0 = vtk.vtkAppendFilter()
            for adj in adjLabels:
                adjThresh = vtk.vtkThreshold()
                adjThresh.SetInputData(usgComp0)
                adjThresh.SetInputArrayToProcess(
                    0, 0, 0, vtk.vtkDataObject.FIELD_ASSOCIATION_CELLS, boundaryArrayName
                )
                adjThresh.SetSelectedComponent(1)  # the "other" component
                adjThresh.SetUpperThreshold(adj)
                adjThresh.SetLowerThreshold(adj)
                adjThresh.Between(adj)
                adjThresh.Update()
                appendedAdjsComp0.AddInputData(adjThresh.GetOutput())

            appendedAdjsComp0.Update()

            # We'll subtract those from usgComp0.
            # Convert each to polydata and use cell IDs. 

            usgToRemoveComp0 = appendedAdjsComp0.GetOutput()
            finalComp0 = subtractCellsById(usgComp0, usgToRemoveComp0)
        else:
            # If no adjacency labels to exclude, keep everything from threshComp0
            finalComp0 = usgComp0

        # Convert finalComp0 to polydata
        geomOutComp0 = vtk.vtkGeometryFilter()
        geomOutComp0.SetInputData(finalComp0)
        geomOutComp0.Update()


        # ---------------------------
        # 2. Threshold: component 1 == labelID
        # ---------------------------
        threshComp1 = vtk.vtkThreshold()
        threshComp1.SetInputData(inputPolyData)
        threshComp1.SetInputArrayToProcess(
            0, 0, 0, vtk.vtkDataObject.FIELD_ASSOCIATION_CELLS, boundaryArrayName
        )
        threshComp1.SetSelectedComponent(1)
        threshComp1.SetUpperThreshold(labelID)
        threshComp1.SetLowerThreshold(labelID)
        threshComp1.Between(labelID)
        threshComp1.Update()

        geometryComp1 = vtk.vtkGeometryFilter()
        geometryComp1.SetInputConnection(threshComp1.GetOutputPort())
        geometryComp1.Update()

        usgComp1 = polyDataToUnstructuredGrid(geometryComp1.GetOutput())

        # Exclude adjacency from component 0 if needed
        if len(adjLabels) > 0:
            appendedAdjsComp1 = vtk.vtkAppendFilter()
            for adj in adjLabels:
                adjThresh = vtk.vtkThreshold()
                adjThresh.SetInputData(usgComp1)
                adjThresh.SetInputArrayToProcess(
                    0, 0, 0, vtk.vtkDataObject.FIELD_ASSOCIATION_CELLS, boundaryArrayName
                )
                adjThresh.SetSelectedComponent(0)  # the "other" component now
                adjThresh.SetUpperThreshold(adj)
                adjThresh.SetLowerThreshold(adj)
                adjThresh.Between(adj)
                adjThresh.Update()
                appendedAdjsComp1.AddInputData(adjThresh.GetOutput())

            appendedAdjsComp1.Update()
            usgToRemoveComp1 = appendedAdjsComp1.GetOutput()
            finalComp1 = subtractCellsById(usgComp1, usgToRemoveComp1)
        else:
            finalComp1 = usgComp1

        geomOutComp1 = vtk.vtkGeometryFilter()
        geomOutComp1.SetInputData(finalComp1)
        geomOutComp1.Update()

        swapBoundaryLabelsComponents(geomOutComp1.GetOutput())

        # ---------------------------
        # 3. Combine the results
        # ---------------------------
        appender = vtk.vtkAppendPolyData()
        appender.AddInputData(geomOutComp0.GetOutput())
        appender.AddInputData(geomOutComp1.GetOutput())

        # At this point, appender.GetOutput() is a vtkPolyData combining both sets.
        # You may need a clean-up (e.g. vtkCleanPolyData) if there are duplicates:
        cleaner = vtk.vtkCleanPolyData()
        cleaner.SetInputConnection(appender.GetOutputPort())
        cleaner.Update()

        return cleaner.GetOutput()

    def polyDataToUnstructuredGrid(polyData: vtk.vtkPolyData) -> vtk.vtkUnstructuredGrid:
        """
        Helper function to convert a vtkPolyData to vtkUnstructuredGrid
        (useful for more thresholding steps).
        """
        polyDataToUG = vtk.vtkAppendFilter()
        polyDataToUG.AddInputData(polyData)
        polyDataToUG.Update()
        return polyDataToUG.GetOutput()

    def subtractCellsById(
        sourceUG: vtk.vtkUnstructuredGrid,
        removeUG: vtk.vtkUnstructuredGrid,
        originalIdArrayName="vtkOriginalCellIds"
    ) -> vtk.vtkUnstructuredGrid:
        """
        Build a set of OriginalCellIds from 'removeUG' and
        remove them from 'sourceUG' by thresholding on a KeepMask array.
        Returns a new vtkUnstructuredGrid with those cells excluded.
        """

        # 1) Collect the IDs to remove
        removeIDArray = removeUG.GetCellData().GetArray(originalIdArrayName)
        if not removeIDArray:
            # Nothing to remove if no ID array found
            return sourceUG

        removeIDSet = set()
        for i in range(removeUG.GetNumberOfCells()):
            removeIDSet.add(removeIDArray.GetValue(i))

        # 2) Create keep/remove mask in sourceUG and threshold
        filteredUG = makeCellMaskById(
            sourceUG=sourceUG,
            removeIDSet=removeIDSet,
            originalIdArrayName=originalIdArrayName
        )

        return filteredUG

    def makeCellMaskById(
        sourceUG: vtk.vtkUnstructuredGrid,
        removeIDSet: set,
        originalIdArrayName="OriginalCellIds",
        maskArrayName="KeepMask"
    ) -> vtk.vtkUnstructuredGrid:
        """
        From 'sourceUG', create a new 'KeepMask' cell-data array:
        - 1 if cell's OriginalCellIds is *not* in removeIDSet
        - 0 if cell's OriginalCellIds *is* in removeIDSet
        Then threshold on KeepMask >= 1 to output a new vtkUnstructuredGrid
        containing only the "kept" cells.
        """

        # 1) Create the mask array
        numCells = sourceUG.GetNumberOfCells()
        keepMask = vtk.vtkFloatArray()
        keepMask.SetName(maskArrayName)
        keepMask.SetNumberOfComponents(1)
        keepMask.SetNumberOfTuples(numCells)

        origIdArray = sourceUG.GetCellData().GetArray(originalIdArrayName)
        if not origIdArray:
            raise ValueError(f"Array '{originalIdArrayName}' not found in CellData.")
        
        for i in range(numCells):
            originalId = origIdArray.GetValue(i)
            if originalId in removeIDSet:
                keepMask.SetValue(i, 0.0)  # to remove
            else:
                keepMask.SetValue(i, 1.0)  # to keep

        sourceUG.GetCellData().AddArray(keepMask)

        # 2) Threshold on keepMask >= 1
        thresh = vtk.vtkThreshold()
        thresh.SetInputData(sourceUG)
        thresh.SetInputArrayToProcess(
            0, 0, 0, vtk.vtkDataObject.FIELD_ASSOCIATION_CELLS, maskArrayName
        )
        # We want to keep cells with mask >= 1
        thresh.SetThresholdFunction(vtk.vtkThreshold().THRESHOLD_UPPER)
        thresh.SetUpperThreshold(0.5)
        thresh.Update()

        return thresh.GetOutput()  # vtkUnstructuredGrid

    def swapBoundaryLabelsComponents(polyData, boundaryArrayName="BoundaryLabels"):
        """
        For each cell in 'polyData', swap the two components of the
        boundaryArrayName cell-data array. i.e. comp0 <-> comp1.
        """
        arr = polyData.GetCellData().GetArray(boundaryArrayName)
        if not arr or arr.GetNumberOfComponents() != 2:
            # Either the array doesn't exist or doesn't have 2 components.
            return

        numTuples = arr.GetNumberOfTuples()

        # A simple approach is to create a new array, then replace the old one.
        swappedArr = vtk.vtkFloatArray()
        swappedArr.SetName(boundaryArrayName)
        swappedArr.SetNumberOfComponents(2)
        swappedArr.SetNumberOfTuples(numTuples)

        for i in range(numTuples):
            comp0 = arr.GetComponent(i, 0)
            comp1 = arr.GetComponent(i, 1)
            # Swap
            arr.SetComponent(i, 0, comp1)
            arr.SetComponent(i, 1, comp0)

    labelArray = labeledSurface.GetCellData().GetArray(labelArrayName)

    # Determine which label values actually exist in the surface
    existingLabels = set()
    for i in range(labelArray.GetNumberOfTuples()):
        existingLabels.add(int(labelArray.GetTuple2(i)[0]))

    # We'll only extract from possibleLabels that actually exist
    labelsToExtract = [lbl for lbl in possibleLabels if lbl in existingLabels]
    if not labelsToExtract:
        raise ValueError("No labels from the given 'possibleLabels' are present in the surface!")

    # ------------------------------------------------
    # 2. Extract each artery sub-surface by label
    # ------------------------------------------------

    standardAdj = {
        1.0: (2.0, 3.0),
        2.0: (1.0, 8.0),
        3.0: (1.0, 9.0),
        4.0: (5.0, 8.0, 11.0),
        5.0: (4.0,),
        6.0: (7.0, 9.0, 12.0),
        7.0: (6.0,),
        8.0: (2.0, 4.0),
        9.0: (3.0, 6.0),
        10.0: (11.0, 12.0),
        11.0: (4.0,),
        12.0: (6.0,)
    }

    # 1) Attach a new array with unique cell IDs.
    attachOriginalCellIds(labeledSurface)
    completeAppender = vtk.vtkAppendPolyData()

    for lbl in labelsToExtract:

        artery = pv.wrap(extractNonStandardAdjSurfaces(labeledSurface, float(lbl), standardAdj))

        #artery = smooth_surface(artery)

        pointLabels = vtk.vtkIntArray()
        pointLabels.SetName("BoundaryLabels")
        pointLabels.SetNumberOfComponents(1)
        pointLabels.SetNumberOfTuples(artery.GetNumberOfPoints())
        
        for i in range(artery.GetNumberOfPoints()):
            pointLabels.SetValue(i, lbl)
            #cellLabels.SetTuple2(i, float(lbl), 0.0)
        
        # Attach this array to the pont data
        artery.GetPointData().AddArray(pointLabels)
        completeAppender.AddInputData(artery)

    cleaner = vtk.vtkCleanPolyData()
    cleaner.ToleranceIsAbsoluteOn()
    cleaner.SetAbsoluteTolerance(0.1)
    cleaner.SetInputConnection(completeAppender.GetOutputPort())
    cleaner.Update()

    #return pv.wrap(cleaner.GetOutput())
    return pv.wrap(completeAppender.GetOutput())
